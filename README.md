# utility
new、apply、call、bind几种方法的实现
## new的实现
基本思想：通过 `new` 创建新对象，最终返回一个对象，该对象具有构造函数的实例属性，该对象的原型 `__proto__` 指向构造函数的原型对象<br>
实现步骤：<br>
1. 创建一个新对象 `obj`
2. `obj.__proto__ = Constructor.prototype`
3. `Constructor.apply(obj)`：让构造函数的 `this` 指向新创建的对象 `obj`
4. 返回对象：如果构造函数有返回值，需要判断返回值的类型
  1. 如果返回值是一个对象，则返回这个对象
  2. 如果返回值不是一个对象，则返回新创建的对象
## call和apply的实现
基本思想：给指定对象新增一个属性，将要执行的函数赋值给对象属性，执行对象属性对应的函数<br>
实现步骤：<br>
1. 将当前运行的函数赋值给指定对象的属性：`obj.func = this`（用`this`保存当前运行的函数）
2. 运行`obj.func(args)`
3. 删除对象属性`delete obj.func`
## bind的实现
基本思想：返回一个函数，将调用函数和指定的对象进行绑定<br>
实现步骤：
1. 保存调用`bind()`的函数`func`
2. 保存传入`bind()`的剩余参数（这些参数要传入最终执行的函数中）
3. 返回一个函数`bindFunc`，函数通过执行`func.apply(obj)`实现作用域绑定
4. 设置返回函数的原型（通过设置一个中转函数，中转函数的原型等于调用函数的原型，返回函数的原型等于中转函数的原型）
